#' DianaClustering:
#' @description Applies DIANA (DIvisive ANAlysis) clustering to a transcriptomics dataset and appends a cluster column to this dataset for all genes.
#'
#' @param dataset A transcriptomics dataset. First columns should be gene names. All other columns should be expression levels. Not needed if an argument to distance is given.
#' @param distance A distance matrix. If a distance matrix has already been created (such as by using the DistanceGen function), the matrix can be passed to this function to save time. If a distance matrix is not provided then it will be generated by the function.
#' @param k The total number of clusters.
#' @param metric The distance metric to be used to calculate the distances between genes. See parallelDist::parDist for all accepted arguments. Also allows the option of 'abs.correlation'. Not used if a distance matrix is provided.
#' @param nthreads Number of processor threads to be used for calculating the distance matrix. If not specifed then the maximum number of logical cores are used.
#' @param scale Logical. If TRUE then each gene will be scaled
#' @param center If the gene activity should be centered before clustering.
#' @return Returns transcriptomics dataset provided with additional cluster column appended denoted which cluster each gene belongs to.
#' @examples
#' diana.df <- DianaClustering(Laurasmappings, k= 75)
#'
#' @export
DianaClustering <- function(dataset = NULL, distance = NULL, k = 10, metric = "euclidean", nthreads = NULL,
    scale = TRUE, center = TRUE) {

    if (is.null(dataset) == TRUE & is.null(distance) == TRUE) {
        # Check that either a dataset or a distance matrix has been provided
        stop("Either a transcriptomics dataset or a distance matrix needs to be provided!")
    }


    if (is.null(nthreads) == TRUE) {
        # Set the threads to maximum if none is specified
        nthreads <- parallel::detectCores()
    }

    if (is.null(distance) == TRUE) {
        dataset.sc <- CircadianTools::GeneScale(dataset, scale = scale, center = center)  # Center / scale the gene activity for each gene
        distance <- CircadianTools::DistanceGen(dataset = dataset.sc, metric = metric, nthreads = nthreads)
    }


    fit <- cluster::diana(distance)  # Run the clustering process
    clusters <- cutree(as.hclust(fit), k = k)  # Cut the dendogram such that there are k clusters
    dataset$cluster <- clusters  # Append the cluster column to the dataset
    return(dataset)
}


#' DianaParamSelection
#' @description Runs DIANA (DIvisive ANAlysis) clustering with differing numbers of partitions and returns validation metrics.
#' @param dataset A transcriptomics dataset. Preferably filtered first. First columns should be gene names. All other columns should be expression levels.
#' @param distance A distance matrix. If a distance matrix has already been created (such as by using the DistanceGen function), the matrix can be passed to this function to save time. If a distance matrix is not provided then it will be generated by the function.
#' @param k A numeric vector giving the number of clusters to be evaluated.
#' @param scale Logical. If TRUE then each gene will be scaled
#' @param nthreads The number of threads to be used for parallel computations.If NULL then the maximum number of threads available will be used.
#' @param metric The distance metric to be used to calculate the distances between genes. See parallelDist::parDist for all accepted arguments. Also allows the option of 'abs.correlation'. Not used if a distance matrix is provided.
#' filter.df <- CombiFilter(Laurasmappings)
#' k.options <- seq(10,100, by=10)
#' diana.validation <- DianaParamSelection(filterdf, k=k.options)
#' @export
DianaParamSelection <- function(dataset = NULL, distance = NULL, k = c(2, 5, 10),
                                metric = "euclidean", nthreads = 4, scale = TRUE) {

    if (is.null(dataset) == TRUE & is.null(distance) == TRUE) {
        # Check that either a dataset or a distance matrix has been provided
        stop("Either a transcriptomics dataset or a distance matrix needs to be provided!")
    }


    if (is.null(nthreads) == TRUE) {
        # Set the threads to maximum if null is specified
        nthreads <- parallel::detectCores()
    }

    `%dopar%` <- foreach::`%dopar%`  # Load the dopar binary operator from foreach package


    if (is.null(distance) == TRUE) {
        dataset.sc <- CircadianTools::GeneScale(dataset, scale = scale)  # Center each gene
        distance <- CircadianTools::DistanceGen(dataset = dataset.sc, metric = metric, nthreads = nthreads)
    }


    fit <- cluster::diana(distance)  # Run Diana clustering

    cl <- parallel::makeForkCluster(nthreads)  # Create cluster for parallelism
    doParallel::registerDoParallel(cl)

    result.df <- foreach::foreach(i = k, .combine = rbind) %dopar% {
        cluster <- cutree(fit, k = i)  # Cut tree
        dunn <- clValid::dunn(distance, cluster)  # Calculate Dunn index
        connect <- (clValid::connectivity(distance, cluster))  # Calculate connectivity
        silhoutte_values <- cluster::silhouette(cluster, distance)
        silhouette <- mean(silhoutte_values[, 3])  # Calculate Silhouette width

        data.frame(i, dunn, connect, silhouette, "DIANA")  # Make row of result.df

    }
    parallel::stopCluster(cl)
    colnames(result.df) <- c("k", "Dunn", "Connectivity", "Silhouette", "Method")  # Column headings
    return(result.df)
}



