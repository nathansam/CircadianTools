#' DianaClustering:
#' @description Applies DIANA (DIvisive ANAlysis) clustering to a
#'  transcriptomics dataset and appends a cluster column to this dataset for
#'   all genes.
#'
#' @param dataset A transcriptomics dataset. First columns should be gene names.
#'  All other columns should be expression levels. Not needed if an argument to
#'   distance is given.
#' @param distance A distance matrix. If a distance matrix has already been
#'  created (such as by using the \link{DistanceGen} function), the matrix can
#'  be passed to this function to save time. If a distance matrix is not
#'  provided then it will be generated by the function.
#' @param k The total number of clusters.
#' @param metric The distance metric to be used to calculate the distances
#'  between genes. See parallelDist::parDist for all accepted arguments. Also
#'  allows the option of 'abs.correlation'. Not used if a distance matrix is
#'  provided.
#' @param nthreads Number of processor threads to be used for calculating the
#'  distance matrix. If not specifed then the maximum number of logical cores
#'  are used.
#' @param scale Logical. If TRUE then each gene will be scaled
#' @param center If the gene activity should be centered before clustering.
#' @return Returns transcriptomics dataset provided with additional cluster
#'  column appended denoted which cluster each gene belongs to.
#' @examples
#' diana.df <- DianaClustering(Laurasmappings, k= 75)
#'
#' @export
DianaClustering <- function(dataset = NULL, distance = NULL, k = 10,
                            metric = "euclidean", nthreads = NULL,
                            scale = TRUE, center = TRUE) {

    if (is.null(dataset) == TRUE & is.null(distance) == TRUE) {
        # Check that either a dataset or a distance matrix has been provided
        stop("Either a transcriptomics dataset or a distance matrix needs to be provided!")
    }


    if (is.null(nthreads) == TRUE) {
        # Set the threads to maximum if none is specified
        nthreads <- parallel::detectCores()
    }

    if (is.null(distance) == TRUE) {
        # Center / scale the gene activity for each gene
        dataset.sc <- CircadianTools::GeneScale(dataset,
                                                scale = scale, center = center)
        distance <- CircadianTools::DistanceGen(dataset = dataset.sc,
                                          metric = metric, nthreads = nthreads)
    }


    fit <- cluster::diana(distance)  # Run the clustering process
    # Cut the dendogram such that there are k clusters
    clusters <- cutree(as.hclust(fit), k = k)
    dataset$cluster <- clusters  # Append the cluster column to the dataset
    return(dataset)
}


#' DianaParamSelection
#' @description Runs DIANA (DIvisive ANAlysis) clustering with differing numbers
#'  of partitions and returns validation metrics.
#' @param dataset A transcriptomics dataset. Preferably filtered first. First
#'  columns should be gene names. All other columns should be expression levels.
#' @param distance A distance matrix. If a distance matrix has already been
#'  created (such as by using the DistanceGen function), the matrix can be
#'  passed to this function to save time. If a distance matrix is not provided
#'  then it will be generated by the function.
#' @param k A numeric vector giving the number of clusters to be evaluated.
#' @param scale Logical. If TRUE then each gene will be scaled
#' @param nthreads The number of threads to be used for parallel computations.If
#'  NULL then the maximum number of threads available will be used.
#' @param metric The distance metric to be used to calculate the distances
#'  between genes. See parallelDist::parDist for all accepted arguments. Also
#'  allows the option of 'abs.correlation'. Not used if a distance matrix is
#'  provided.
#' @examples
#' filter.df <- CombiFilter(Laurasmappings)
#' k.options <- seq(10,100, by=10)
#' diana.validation <- DianaParamSelection(filterdf, k=k.options)
#' @export
DianaParamSelection <- function(dataset = NULL, distance = NULL,
                                k = c(2, 5, 10), metric = "euclidean",
                                nthreads = 4, scale = TRUE) {

    if (is.null(dataset) == TRUE & is.null(distance) == TRUE) {
        # Check that either a dataset or a distance matrix has been provided
        stop("Either a transcriptomics dataset or a distance matrix needs to be provided!")
    }


    if (is.null(nthreads) == TRUE) {
        # Set the threads to maximum if null is specified
        nthreads <- parallel::detectCores()
    }

    # Load the dopar binary operator from foreach package
    `%dopar%` <- foreach::`%dopar%`


    if (is.null(distance) == TRUE) {
        # Center each gene
        dataset.sc <- CircadianTools::GeneScale(dataset, scale = scale)
        distance <- CircadianTools::DistanceGen(dataset = dataset.sc,
                                        metric = metric, nthreads = nthreads)
    }


    fit <- cluster::diana(distance)  # Run Diana clustering

    cl <- parallel::makeForkCluster(nthreads)  # Create cluster for parallelism
    doParallel::registerDoParallel(cl)

    result.df <- foreach::foreach(i = k, .combine = rbind) %dopar% {
        cluster <- cutree(fit, k = i)  # Cut tree
        # Calculate Dunn index
        dunn <- clValid::dunn(distance, cluster)
        # Calculate connectivity
        connect <- (clValid::connectivity(distance, cluster))
        # Calculate Silhouette width
        silhoutte_values <- cluster::silhouette(cluster, distance)
        silhouette <- mean(silhoutte_values[, 3])

        # Make row of result.df
        data.frame(i, dunn, connect, silhouette, "DIANA")

    }
    parallel::stopCluster(cl)
    # Column headings
    colnames(result.df) <- c("k", "Dunn", "Connectivity",
                             "Silhouette", "Method")
    return(result.df)
}
